/**
 * Name: vite-plugin-fake-server
 * Version: 2.2.0
 * Author: Condor Hero
 * Homepage: https://github.com/condorheroblog/vite-plugin-fake-server/blob/main/README.md
 * License MIT Â© 2023-Present
 */

import { existsSync } from 'node:fs';
import { mkdir, writeFile, readdir, stat, copyFile } from 'node:fs/promises';
import { join, extname, isAbsolute } from 'node:path';
import process from 'node:process';
import colors from 'picocolors';
import { globSync } from 'tinyglobby';
import { normalizePath, build } from 'vite';
import { match } from 'path-to-regexp';
import EventEmitter from 'node:events';
import { bundleImport } from 'bundle-import';
import chokidar from 'chokidar';
import { createRequire } from 'node:module';
import { STATUS_CODES } from 'node:http';
import readline from 'node:readline';

var name = "vite-plugin-fake-server";
var type = "module";
var version = "2.2.0";
var description = "A fake server plugin for Vite.";
var author = "Condor Hero";
var license = "MIT";
var homepage = "https://github.com/condorheroblog/vite-plugin-fake-server/blob/main/README.md";
var repository = {
	type: "git",
	url: "git+https://github.com/condorheroblog/vite-plugin-fake-server.git",
	directory: "packages/vite-plugin-fake-server"
};
var bugs = {
	url: "https://github.com/condorheroblog/vite-plugin-fake-server/issues"
};
var keywords = [
	"vite-plugin-fake-server",
	"vite-plugin-fake",
	"vite-plugin-faker",
	"vite-plugin-mock-server",
	"vite-plugin-mock",
	"faker-server"
];
var exports = {
	".": {
		"import": "./dist/index.mjs",
		require: "./dist/index.cjs"
	},
	"./client": {
		"import": "./dist/client.mjs",
		require: "./dist/client.cjs"
	}
};
var main = "dist/index.cjs";
var module = "dist/index.mjs";
var types = "dist/index.d.cts";
var typesVersions = {
	"*": {
		"*": [
			"./dist/*",
			"./dist/index.d.ts"
		]
	}
};
var files = [
	"dist"
];
var scripts = {
	prepublishOnly: "nr build",
	test: "vitest",
	dev: "esno ./src/index.ts",
	build: "rimraf dist && rollup -c",
	"build:watch": "rimraf dist && rollup -c -w",
	typecheck: "tsc --noEmit"
};
var dependencies = {
	"bundle-import": "^0.0.2",
	chokidar: "^4.0.1",
	"path-to-regexp": "^8.2.0",
	picocolors: "^1.1.1",
	tinyglobby: "^0.2.10"
};
var devDependencies = {
	vite: "^6.0.3"
};
var publishConfig = {
	access: "public",
	registry: "https://registry.npmjs.org"
};
var pkg = {
	name: name,
	type: type,
	version: version,
	description: description,
	author: author,
	license: license,
	homepage: homepage,
	repository: repository,
	bugs: bugs,
	keywords: keywords,
	exports: exports,
	main: main,
	module: module,
	types: types,
	typesVersions: typesVersions,
	files: files,
	scripts: scripts,
	dependencies: dependencies,
	devDependencies: devDependencies,
	publishConfig: publishConfig
};

const FAKE_FILE_EXTENSIONS = ["ts", "js", "mjs", "cjs", "cts", "mts"];
const INFIX_NAME = "fake";

function getWatchPaths({ infixName, extensions, include }) {
  let watchPath;
  const extString = extensions.length === 1 ? extensions[0] : `{${extensions.join(",")}}`;
  if (infixName && infixName.length > 0) {
    watchPath = `/**/*.${infixName}.${extString}`;
  } else {
    watchPath = `/**/*.${extString}`;
  }
  return include.map((path) => normalizePath(join(path, watchPath)));
}

function getFakeFilePath(options, root = process.cwd()) {
  const { include, exclude, extensions, infixName } = options;
  if (!Array.isArray(include) || include.length === 0) {
    return [];
  }
  const watchDir = getWatchPaths({ infixName, extensions, include });
  return globSync(watchDir, {
    ignore: exclude,
    cwd: root
  });
}

function parallelLoader(promises, limit = Infinity) {
  const len = promises.length;
  if (len === 0) {
    return Promise.resolve([]);
  }
  let current = 0;
  const result = [];
  let resolvedCount = 0;
  return new Promise((resolve, reject) => {
    function processNext() {
      const index = current;
      current = index + 1;
      const promise = promises[index];
      Promise.resolve(promise()).then((res) => {
        if (Array.isArray(res)) {
          result.push(...res);
        } else {
          result.push(res);
        }
        resolvedCount = resolvedCount + 1;
        if (resolvedCount === len) {
          resolve(result);
        }
        if (current < len)
          processNext();
      }).catch((reason) => reject(reason));
    }
    for (let i = 0; i < limit && i < len; i++) {
      processNext();
    }
  });
}

function resolveOptions(options = {}) {
  options.include ?? (options.include = [INFIX_NAME]);
  const include = Array.isArray(options.include) ? options.include : [options.include];
  if (include.length === 0) {
    throw new Error("Invalid include option");
  }
  options.exclude ?? (options.exclude = []);
  const exclude = Array.isArray(options.exclude) ? options.exclude : [options.exclude];
  let infixName;
  if (typeof options.infixName === "boolean") {
    if (options.infixName) {
      infixName = INFIX_NAME;
    } else {
      infixName = false;
    }
  } else if (typeof options.infixName === "string") {
    if (options.infixName.length === 0) {
      infixName = false;
    } else {
      infixName = options.infixName;
    }
  } else {
    infixName = INFIX_NAME;
  }
  return {
    include,
    exclude,
    infixName,
    extensions: options.extensions || FAKE_FILE_EXTENSIONS
  };
}

const PORT = 8888;
const OUTPUT_DIR = "fakeServer";
async function generateFakeServer(options, config) {
  const buildOptions = options.build === true ? { port: PORT, outDir: OUTPUT_DIR } : options.build;
  const { port = PORT, outDir = OUTPUT_DIR } = buildOptions;
  const cwd = process.cwd();
  const outputDir = join(cwd, outDir);
  const outputList = [
    {
      filename: join(outputDir, "index.js"),
      source: generatorServerEntryCode(port, options, config)
    },
    {
      filename: join(outputDir, "package.json"),
      source: generatePackageJson()
    }
  ];
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }
  options.include.forEach(async (includePath) => {
    await copyFakeFiles(join(cwd, includePath), join(outputDir, includePath));
  });
  for (const { filename, source } of outputList) {
    await writeFile(filename, source, "utf-8");
  }
  console.log(`
[${name}]Builded a independently service in`, colors.green(outputDir), "\n");
  console.log(colors.yellow("\nThis is just a template, you can adjust it according to your needs\n"));
  console.log(
    `We suggest that you begin by typing:

  ${colors.blue("cd")} ${outDir}
  ${colors.blue("npm install")}
  ${colors.blue(
      "npm run start"
    )}

Happy Hacking!
See more: ${colors.underline(
      colors.blue("https://github.com/condorheroblog/vite-plugin-fake-server#build")
    )}`
  );
}
function generatePackageJson() {
  const fakePkg = {
    name: "fake-server",
    version,
    private: true,
    type: "module",
    scripts: {
      start: "node index.js"
    },
    dependencies: {
      connect: "latest",
      [name]: `^${version}`
    }
  };
  return JSON.stringify(fakePkg, null, 2);
}
function generatorServerEntryCode(port, options, config) {
  return `import connect from "connect";
import { createFakeMiddleware, createLogger } from "${name}";

const loggerOutput = createLogger(${JSON.stringify(config.logLevel)}, {
	allowClearScreen: ${config.clearScreen},
	// customLogger: ${config.customLogger},
});

async function main() {

	const app = connect();
	const middleware = await createFakeMiddleware(
		{
			...${JSON.stringify(options, null, 2)},
			loggerOutput,
			// config.root
			root: process.cwd(),
		},
		app
	);
	app.use(middleware);

	app.listen(${port});
	console.log("listen: http://localhost:${port}");
}

main();
`;
}
async function copyFakeFiles(sourceDir, targetDir) {
  try {
    if (!existsSync(targetDir)) {
      await mkdir(targetDir, { recursive: true });
    }
    const files = await readdir(sourceDir);
    for (const file of files) {
      const sourcePath = join(sourceDir, file);
      const targetPath = join(targetDir, file);
      const fileStatus = await stat(sourcePath);
      if (fileStatus.isDirectory()) {
        await copyFakeFiles(sourcePath, targetPath);
      } else {
        const ext = extname(file).toLowerCase().slice(1);
        if (FAKE_FILE_EXTENSIONS.includes(ext)) {
          await copyFile(sourcePath, targetPath);
        }
      }
    }
  } catch (error) {
    console.error(`Error copying fake files: ${error}`);
  }
}

function defineFakeRoute(config) {
  return config;
}

var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), member.set(obj, value), value);
var _moduleCache, _fakeFileDeps, _fakeData;
class FakeFileLoader extends EventEmitter {
  constructor(options) {
    super();
    this.options = options;
    __privateAdd(this, _moduleCache, /* @__PURE__ */ new Map());
    __privateAdd(this, _fakeFileDeps, /* @__PURE__ */ new Map());
    __privateAdd(this, _fakeData, []);
    __publicField(this, "watcher");
    __publicField(this, "watcherDeps");
    this.options = options;
  }
  get fakeData() {
    return __privateGet(this, _fakeData);
  }
  async start() {
    this.watchFakeFileDeps();
    await this.watchFakeFile();
    const { include, exclude, extensions, infixName, root } = this.options;
    const fakeFilePathArr = getFakeFilePath({ exclude, include, extensions, infixName }, root);
    const fakeFilePathFunc = fakeFilePathArr.map((relativeFilePath) => () => this.loadFakeData(relativeFilePath));
    await parallelLoader(fakeFilePathFunc, 10);
    this.updateFakeData();
  }
  async watchFakeFile() {
    const { include, watch, root, exclude, loggerOutput, extensions, infixName, logger } = this.options;
    if (include && include.length && watch) {
      const watcher = chokidar.watch(include, {
        cwd: root,
        ignoreInitial: true,
        ignored: [
          ...exclude,
          (path, stats) => Boolean(stats?.isFile()) && !extensions.some((extItem) => {
            if (infixName && infixName.length > 0)
              return path.endsWith(`.${infixName}.${extItem}`);
            return path.endsWith(`.${extItem}`);
          })
        ]
      });
      this.watcher = watcher;
      const handleFileEvent = async (eventType, relativeFilePath, logger2) => {
        const unixPath = normalizePath(relativeFilePath);
        if (logger2) {
          loggerOutput.info(colors.green(`fake file ${eventType} ${colors.dim(unixPath)}`), {
            timestamp: true,
            clear: true
          });
        }
        if (eventType === "unlink") {
          __privateGet(this, _moduleCache).delete(normalizePath(unixPath));
        } else {
          await this.loadFakeData(unixPath);
        }
        this.updateFakeData();
      };
      watcher.on("add", async (relativeFilePath) => {
        await handleFileEvent("add", relativeFilePath, logger);
      });
      watcher.on("change", async (relativeFilePath) => {
        await handleFileEvent("change", relativeFilePath, logger);
      });
      watcher.on("unlink", async (relativeFilePath) => {
        await handleFileEvent("unlink", relativeFilePath, logger);
      });
    }
  }
  watchFakeFileDeps() {
    const { include, watch, root } = this.options;
    if (include && include.length && watch) {
      const watcherDeps = chokidar.watch([], {
        cwd: root,
        ignoreInitial: true
      });
      this.watcherDeps = watcherDeps;
      watcherDeps.on("change", (relativeFilePath) => {
        const unixPath = normalizePath(relativeFilePath);
        if (__privateGet(this, _fakeFileDeps).has(unixPath)) {
          const fakeFiles = __privateGet(this, _fakeFileDeps).get(unixPath);
          if (fakeFiles) {
            fakeFiles.forEach(async (filePath) => {
              await this.loadFakeData(filePath);
              this.updateFakeData();
            });
          }
        }
      });
      watcherDeps.on("unlink", async (relativeFilePath) => {
        const unixPath = normalizePath(relativeFilePath);
        if (__privateGet(this, _fakeFileDeps).has(unixPath)) {
          __privateGet(this, _fakeFileDeps).delete(unixPath);
        }
      });
      const oldDeps = [];
      this.on("update:deps", () => {
        const deps = [];
        for (const [dep] of __privateGet(this, _fakeFileDeps).entries()) {
          deps.push(dep);
        }
        const exactDeps = deps.filter((dep) => !oldDeps.includes(dep));
        if (exactDeps.length > 0) {
          watcherDeps.add(exactDeps);
        }
      });
    }
  }
  async loadFakeData(filepath) {
    const fakeCodeData = [];
    let fakeFileDependencies = {};
    try {
      const { mod, dependencies } = await bundleImport({ filepath, cwd: this.options.root });
      fakeFileDependencies = dependencies;
      const resolvedModule = mod.default || mod;
      if (Array.isArray(resolvedModule)) {
        fakeCodeData.push(...resolvedModule);
      } else {
        fakeCodeData.push(resolvedModule);
      }
    } catch (error) {
      this.options.loggerOutput.error(colors.red(`failed to load module from ${filepath}`), {
        error,
        timestamp: true
      });
    }
    __privateGet(this, _moduleCache).set(filepath, fakeCodeData);
    this.updateFakeFileDeps(filepath, fakeFileDependencies);
    return fakeCodeData;
  }
  updateFakeFileDeps(filepath, deps) {
    Object.keys(deps).forEach((mPath) => {
      const imports = deps[mPath].imports.map((_) => _.path);
      imports.forEach((dep) => {
        if (!__privateGet(this, _fakeFileDeps).has(dep)) {
          __privateGet(this, _fakeFileDeps).set(dep, /* @__PURE__ */ new Set());
        }
        const cur = __privateGet(this, _fakeFileDeps).get(dep);
        cur.add(filepath);
      });
    });
    this.emit("update:deps");
  }
  updateFakeData() {
    let fakeData = [];
    for (const value of __privateGet(this, _moduleCache).values()) {
      fakeData = [...fakeData, ...value];
    }
    __privateSet(this, _fakeData, fakeData);
  }
  close() {
    this.watcher?.close();
    this.watcherDeps?.close();
  }
}
_moduleCache = new WeakMap();
_fakeFileDeps = new WeakMap();
_fakeData = new WeakMap();

/**
 * Sleeps for a specified amount of time.
 * @param {number} time - The time to sleep in milliseconds.
 * @returns {Promise<number>} - A Promise that resolves with the timer ID.
 */
function sleep(time) {
	return new Promise((resolve) => {
		const timer = setTimeout(() => {
			resolve(timer);
			clearTimeout(timer);
		}, time);
	});
}

function sleepSync(ms) {
	if (ms <= 0) {
		return;
	}
	const start = performance.now();
	while (performance.now() - start < ms);
}

/**
 * Parses a string into a JSON object.
 * @param {string} str - The string to be parsed.
 * @returns {object} - The parsed to JSON. If parsing fails, a input string is returned.
 */
function tryToJSON(str) {
	let result = "";
	try {
		result = JSON.parse(str);
	}
	catch {
		result = str;
	}
	return result;
}

function createSimulateResponse(sleepFn) {
	/**
	 * Simulates a server response.
	 * @param {object} req - The request object.
	 * @param {Array} fakeModuleList - The list of fake modules.
	 * @param {object} config - The configuration object.
	 * @returns {import('./types').SimulateServerResponseType} - A Promise that resolves with the server response.
	 */
	return function simulateServerResponse(req = {}, fakeModuleList = [], config = {}) {
		const {
			match,
			basename = "",
			defaultTimeout = 0,
			globalResponseHeaders = {},
		} = config;

		/**
		 * Join two paths into a complete path
		 */

		function joinPathname(a, b) {
			const aPathname = new URL(a, "http://localhost:5173/").pathname;
			const bPathname = new URL(b, "http://localhost:5173/").pathname;
			return aPathname.endsWith("/") ? aPathname.slice(0, -1) + bPathname : aPathname + bPathname;
		}

		if (req.url) {
			const instanceURL = new URL(req.url, "http://localhost:5173/");

			// https://nodejs.org/api/url.html#urlpathname
			// Invalid URL characters included in the value assigned to the pathname property are percent-encoded
			const pathname = instanceURL.pathname;

			const matchRequest = fakeModuleList.find((item) => {
				if (!pathname || !item || !item.url) {
					return false;
				}
				const method = item.method ?? "GET";
				const reqMethod = req.method ?? "GET";
				if (method.toUpperCase() !== reqMethod.toUpperCase()) {
					return false;
				}
				const realURL = joinPathname(basename, item.url);
				return !!match(realURL)(pathname);
			});
			if (matchRequest) {
				const {
					response,
					rawResponse,
					timeout = defaultTimeout,
					statusCode,
					statusText,
					url,
					headers: responseHeaders = {},
				} = matchRequest;

				const joinedUrl = joinPathname(basename, url);
				const urlMatch = match(joinedUrl, { encode: encodeURI });

				const searchParams = instanceURL.searchParams;
				const query = {};
				for (const [key, value] of searchParams.entries()) {
					if (Object.prototype.hasOwnProperty.call(query, key)) {
						const queryValue = query[key];
						if (Array.isArray(queryValue)) {
							queryValue.push(value);
						}
						else {
							query[key] = [queryValue, value];
						}
					}
					else {
						query[key] = value;
					}
				}

				let params = {};

				if (pathname) {
					const matchParams = urlMatch(pathname);
					if (matchParams) {
						params = matchParams.params;
					}
				}

				const result = {
					response,
					rawResponse,
					timeout,
					statusCode: statusCode ?? 200,
					statusText,
					url: req.url,
					query,
					params,
					responseHeaders: new Headers({ ...globalResponseHeaders, ...responseHeaders }),
				};
				// timeout
				const delayPromise = timeout ? sleepFn(timeout) : false;
				return delayPromise && delayPromise?.then ? delayPromise.then(() => result) : result;
			}
		}
	};
}

const simulateServerResponse = createSimulateResponse(sleep);

const simulateServerResponseSync = createSimulateResponse(sleepSync);

const require = createRequire(import.meta.url);
async function buildPackage(packageName) {
  const camelCasePackageName = packageName.replace(/-\w/g, (str) => str[1].toUpperCase());
  const result = await build({
    // Do not use a configuration file
    configFile: false,
    build: {
      commonjsOptions: {
        // Vite6 changes the default behavior of strictRequires from "auto" to "true".
        strictRequires: "auto"
      },
      // Do not output files
      write: false,
      lib: {
        // Entry file is the specified package path
        entry: require.resolve(packageName),
        // Convert package name to camel case
        name: camelCasePackageName,
        // Output format is iife
        formats: ["iife"],
        // Output file name is the same as the package name
        fileName: packageName
      },
      rollupOptions: {
        output: {
          // Export method is named export
          exports: "named",
          // Allow extension of existing global variables
          extend: true
        }
      },
      // Do not minify
      minify: false
    }
  });
  const _result = Array.isArray(result) ? result[0] : result;
  if (!("output" in _result)) {
    return;
  }
  return `window.__VITE__PLUGIN__FAKE__SERVER__.${camelCasePackageName} = (function() { ${_result.output[0].code} return this.${camelCasePackageName}; }).apply({});`;
}

function getRequestData(req) {
  return new Promise((resolve, reject) => {
    let body = "";
    req.on("data", (chunk) => {
      body += chunk.toString();
    });
    req.on("end", () => {
      resolve(body);
    });
    req.on("error", (error) => {
      reject(error);
    });
  });
}

function isFunction(fn) {
  return typeof fn === "function";
}

const LogLevels = {
  silent: 0,
  error: 1,
  warn: 2,
  info: 3
};
let lastType;
let lastMsg;
let sameCount = 0;
function clearScreen() {
  const repeatCount = process.stdout.rows - 2;
  const blank = repeatCount > 0 ? "\n".repeat(repeatCount) : "";
  console.log(blank);
  readline.cursorTo(process.stdout, 0, 0);
  readline.clearScreenDown(process.stdout);
}
function createLogger(level = "info", options = {}) {
  if (options.customLogger) {
    return options.customLogger;
  }
  const timeFormatter = new Intl.DateTimeFormat(void 0, {
    hour: "numeric",
    minute: "numeric",
    second: "numeric"
  });
  const loggedErrors = /* @__PURE__ */ new WeakSet();
  const { prefix = `[${name}]`, allowClearScreen = true } = options;
  const thresh = LogLevels[level];
  const canClearScreen = allowClearScreen && process.stdout.isTTY && !process.env.CI;
  const clear = canClearScreen ? clearScreen : () => {
  };
  function output(type, msg, options2 = {}) {
    if (thresh >= LogLevels[type]) {
      const method = type === "info" ? "log" : type;
      const format = () => {
        if (options2.timestamp) {
          const tag = type === "info" ? colors.cyan(colors.bold(prefix)) : type === "warn" ? colors.yellow(colors.bold(prefix)) : colors.red(colors.bold(prefix));
          return `${colors.dim(timeFormatter.format(/* @__PURE__ */ new Date()))} ${tag} ${msg}`;
        } else {
          return msg;
        }
      };
      if (options2.error) {
        loggedErrors.add(options2.error);
      }
      if (canClearScreen) {
        if (type === lastType && msg === lastMsg) {
          sameCount++;
          clear();
          console[method](format(), colors.yellow(`(x${sameCount + 1})`));
        } else {
          sameCount = 0;
          lastMsg = msg;
          lastType = type;
          if (options2.clear) {
            clear();
          }
          console[method](format());
        }
      } else {
        console[method](format());
      }
    }
  }
  const warnedMessages = /* @__PURE__ */ new Set();
  const logger = {
    hasWarned: false,
    info(msg, opts) {
      output("info", msg, opts);
    },
    warn(msg, opts) {
      logger.hasWarned = true;
      output("warn", msg, opts);
    },
    warnOnce(msg, opts) {
      if (warnedMessages.has(msg))
        return;
      logger.hasWarned = true;
      output("warn", msg, opts);
      warnedMessages.add(msg);
    },
    error(msg, opts) {
      logger.hasWarned = true;
      output("error", msg, opts);
    },
    clearScreen(type) {
      if (thresh >= LogLevels[type]) {
        clear();
      }
    },
    hasErrorLogged(error) {
      return loggedErrors.has(error);
    }
  };
  return logger;
}

async function createFakeMiddleware({ loggerOutput, root, ...options }, httpServer) {
  const fakeLoader = new FakeFileLoader({ ...options, loggerOutput, root });
  await fakeLoader.start();
  if (httpServer) {
    httpServer.on("close", () => {
      fakeLoader.close();
    });
  }
  const { basename, timeout: defaultTimeout, headers: globalResponseHeaders, logger } = options;
  const middleware = async (req, res, next) => {
    const responseResult = await simulateServerResponse(req, fakeLoader.fakeData, {
      match,
      basename,
      defaultTimeout,
      globalResponseHeaders
    });
    if (responseResult) {
      const { rawResponse, response, statusCode, statusText, url, query, params, responseHeaders } = responseResult ?? {};
      if (isFunction(rawResponse)) {
        await Promise.resolve(rawResponse(req, res));
      } else {
        const body = await getRequestData(req);
        for (const key of responseHeaders.keys()) {
          res.setHeader(key, responseHeaders.get(key));
        }
        if (!res.getHeader("Content-Type")) {
          res.setHeader("Content-Type", "application/json");
        }
        res.statusCode = statusCode;
        if (statusText) {
          res.statusMessage = statusText;
        }
        if (isFunction(response)) {
          const fakeResponse = await Promise.resolve(
            response({ url, body: tryToJSON(body), rawBody: body, query, params, headers: req.headers }, req, res)
          );
          if (typeof fakeResponse === "string") {
            res.end(fakeResponse);
          } else {
            res.end(JSON.stringify(fakeResponse, null, 2));
          }
        } else {
          res.end(JSON.stringify(response, null, 2));
        }
      }
      if (logger) {
        loggerOutput.info(colors.green(`request invoke ${colors.cyan(`${req.method} ${req.url}`)}`), {
          timestamp: true,
          clear: true
        });
      }
    } else {
      next();
    }
  };
  return middleware;
}

function createHookTemplate(isSync = false, opts = {}) {
  const commonInit = `
		${tryToJSON.toString()}
		const STATUS_CODES = ${JSON.stringify(STATUS_CODES, null, 2)};

		function headersToObject(headers) {
			const headersObject = {};
			for (const [name, value] of headers.entries()) {
				headersObject[name] = value;
			}
			return headersObject;
		}
	`;
  const getConfig = `{
		match,
		basename: ${JSON.stringify(opts.basename)},
		defaultTimeout: ${JSON.stringify(opts.timeout)},
		globalResponseHeaders: ${JSON.stringify(opts.headers, null, 2)}
	}`;
  const handleAsyncResponseTemplate = `
		const responseIsFunction = typeof response === "function";
		const fakeResponse = responseIsFunction
			? await Promise.resolve(
				response({
					url,
					body: tryToJSON(req.body),
					rawBody: req.body,
					query,
					params,
					headers: requestHeaders,
				}),
			)
			: response;
	`;
  const handleSyncResponseTemplate = `
		const responseIsFunction = typeof response === "function";
		const fakeResponse = responseIsFunction
			? response({
				url,
				body: tryToJSON(req.body),
				rawBody: req.body,
				query,
				params,
				headers: requestHeaders,
			})
			: response;
	`;
  const processTemplate = `
		let apiResponse = "";
		const {
			response,
			statusCode,
			statusText: responseStatusText = STATUS_CODES[statusCode],
			url,
			query,
			params,
			responseHeaders,
		} = responseResult ?? {};
		const statusText = ${JSON.stringify(opts.http2)} ? "" : responseStatusText;
		const requestHeaders = {};
		for (const key in req.headers) {
			requestHeaders[key.toLowerCase()] = req.headers[key];
		}
		${isSync ? handleAsyncResponseTemplate : handleSyncResponseTemplate}
		if(req.isFetch) {
			if (typeof fakeResponse === "string") {
				if (!responseHeaders.get("Content-Type")) {
					responseHeaders.set("Content-Type", "text/plain");
				}
				apiResponse = new Response(
					fakeResponse,
					{
						statusText,
						status: statusCode,
						headers: headersToObject(responseHeaders),
					}
				);
			} else {
				if (!responseHeaders.get("Content-Type")) {
					responseHeaders.set("Content-Type", "application/json");
				}
				apiResponse = new Response(
					JSON.stringify(fakeResponse, null, 2),
					{
						statusText,
						status: statusCode,
						headers: headersToObject(responseHeaders),
					}
				);
			}
		} else {
			const dataResponse = { data: fakeResponse };
			if(!req.type || req.type.toLowerCase() === "text") {
				if (!responseHeaders.get("Content-Type")) {
					responseHeaders.set("Content-Type", "text/plain");
				}
				apiResponse = {
					statusText,
					status: statusCode,
					text: fakeResponse,
					...dataResponse,
					headers: headersToObject(responseHeaders),
				};
			} else if (req.type.toLowerCase() === "json") {
				if (!responseHeaders.get("Content-Type")) {
					responseHeaders.set("Content-Type", "application/json");
				}
				apiResponse = {
					statusText,
					status: statusCode,
					...dataResponse,
					headers: headersToObject(responseHeaders),
				};
			} else if (req.type.toLowerCase() === "document") {
				if (!responseHeaders.get("Content-Type")) {
					responseHeaders.set("Content-Type", "application/xml");
				}
				const parser = new DOMParser();
				const xmlDoc = parser.parseFromString(fakeResponse,"application/xml");
				apiResponse = {
					statusText,
					status: statusCode,
					xml: xmlDoc,
					data: xmlDoc,
					headers: headersToObject(responseHeaders),
				};
			} else {
				// https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/responseType
				// "arraybuffer" | "blob"
				apiResponse = {
					statusText,
					status: statusCode,
					...dataResponse,
					headers: headersToObject(responseHeaders),
				};
			}
		}
		if (${JSON.stringify(opts.logger)}){
			const requestMethod = req.method ? req.method.toUpperCase() : "GET";
			console.log("%c request invoke" + " %c" + requestMethod + " " + req.url, "color: green", "color: blue");
		}
	`;
  const templateAsync = `async function(req, callback) {
		${commonInit}
		${sleep.toString()}
		${createSimulateResponse.toString()};
		const simulateServerResponse = createSimulateResponse(sleep);

		const responseResult = await simulateServerResponse(req, fakeModuleList, ${getConfig});
		if (responseResult) {
			${processTemplate}
			callback(apiResponse);
		} else {
			// next external URL
			callback();
		}
	}`;
  const templateSync = `function(req) {
		${commonInit}
		${sleepSync.toString()}

		${createSimulateResponse.toString()};
		const simulateServerResponseSync = createSimulateResponse(sleepSync);

		const responseResult = simulateServerResponseSync(req, fakeModuleList, ${getConfig});
		if (responseResult) {
			${processTemplate}
			return apiResponse;
		} else {
			// next, will fetch external link
			return;
		}
	}`;
  return isSync ? templateAsync : templateSync;
}

function resolvePluginOptions(options = {}, cwd = process.cwd()) {
  const fakerOptions = resolveOptions(options);
  for (const filePath of fakerOptions.include) {
    const absolutePath = join(cwd, filePath);
    if (!existsSync(absolutePath)) {
      throw new Error(`${filePath} folder does not exist`);
    }
  }
  return {
    ...fakerOptions,
    enableProd: options.enableProd ?? false,
    enableDev: options.enableDev ?? true,
    watch: options.watch ?? true,
    logger: options.logger ?? true,
    timeout: options.timeout,
    basename: options.basename ?? "",
    headers: options.headers ?? {},
    build: options.build ?? false,
    http2: options.http2
  };
}

/* eslint-disable eslint-comments/no-unlimited-disable */
/* eslint-disable */

/**
 * @namespace xhook
 * @description Easily intercept and modify XHR request and response
 *
 * @copyright Jaime Pillora
 * @see https://github.com/jpillora/xhook
 * @version v1.6.2
 * @license MIT Copyright 2023
 *
 * Fix https://github.com/jpillora/xhook/issues/171
 *
 */

function xhook() {
	//The new code belongs to vite-plugin-fake-server
	const isLink = (linkHref) => {
		try {
			new URL(linkHref);
			return true;
		} catch {
			return false;
		}
	};

	const slice = (o, n) => Array.prototype.slice.call(o, n);

	let result = null;

	//find global object
	if (typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope) {
		result = self;
	} else if (typeof global !== "undefined") {
		result = global;
	} else if (window) {
		result = window;
	}

	const windowRef = result;
	const documentRef = result.document;

	const UPLOAD_EVENTS = ["load", "loadend", "loadstart"];
	const COMMON_EVENTS = ["progress", "abort", "error", "timeout"];

	const depricatedProp = (p) => ["returnValue", "totalSize", "position"].includes(p);

	const mergeObjects = function (src, dst) {
		for (let k in src) {
			if (depricatedProp(k)) {
				continue;
			}
			const v = src[k];
			try {
				dst[k] = v;
			} catch (error) {}
		}
		return dst;
	};

	//proxy events from one emitter to another
	const proxyEvents = function (events, src, dst) {
		const p = (event) =>
			function (e) {
				const clone = {};
				//copies event, with dst emitter inplace of src
				for (let k in e) {
					if (depricatedProp(k)) {
						continue;
					}
					const val = e[k];
					clone[k] = val === src ? dst : val;
				}
				//emits out the dst
				return dst.dispatchEvent(event, clone);
			};
		//dont proxy manual events
		for (let event of Array.from(events)) {
			if (dst._has(event)) {
				src[`on${event}`] = p(event);
			}
		}
	};

	//create fake event
	const fakeEvent = function (type) {
		if (documentRef && documentRef.createEventObject != null) {
			const msieEventObject = documentRef.createEventObject();
			msieEventObject.type = type;
			return msieEventObject;
		}
		// on some platforms like android 4.1.2 and safari on windows, it appears
		// that new Event is not allowed
		try {
			return new Event(type);
		} catch (error) {
			return { type };
		}
	};

	//tiny event emitter
	const EventEmitter = function (nodeStyle) {
		//private
		let events = {};
		const listeners = (event) => events[event] || [];
		//public
		const emitter = {};
		emitter.addEventListener = function (event, callback, i) {
			events[event] = listeners(event);
			if (events[event].indexOf(callback) >= 0) {
				return;
			}
			i = i === undefined ? events[event].length : i;
			events[event].splice(i, 0, callback);
		};
		emitter.removeEventListener = function (event, callback) {
			//remove all
			if (event === undefined) {
				events = {};
				return;
			}
			//remove all of type event
			if (callback === undefined) {
				events[event] = [];
			}
			//remove particular handler
			const i = listeners(event).indexOf(callback);
			if (i === -1) {
				return;
			}
			listeners(event).splice(i, 1);
		};
		emitter.dispatchEvent = function () {
			const args = slice(arguments);
			const event = args.shift();
			if (!nodeStyle) {
				args[0] = mergeObjects(args[0], fakeEvent(event));
				Object.defineProperty(args[0], "target", {
					writable: false,
					value: this,
				});
			}
			const legacylistener = emitter[`on${event}`];
			if (legacylistener) {
				legacylistener.apply(emitter, args);
			}
			const iterable = listeners(event).concat(listeners("*"));
			for (let i = 0; i < iterable.length; i++) {
				const listener = iterable[i];
				listener.apply(emitter, args);
			}
		};
		emitter._has = (event) => !!(events[event] || emitter[`on${event}`]);
		//add extra aliases
		if (nodeStyle) {
			emitter.listeners = (event) => slice(listeners(event));
			emitter.on = emitter.addEventListener;
			emitter.off = emitter.removeEventListener;
			emitter.fire = emitter.dispatchEvent;
			emitter.once = function (e, fn) {
				var fire = function () {
					emitter.off(e, fire);
					return fn.apply(null, arguments);
				};
				return emitter.on(e, fire);
			};
			emitter.destroy = () => (events = {});
		}

		return emitter;
	};

	//helper
	const CRLF = "\r\n";

	const objectToString = function (headersObj) {
		const entries = Object.entries(headersObj);

		const headers = entries.map(([name, value]) => {
			return `${name.toLowerCase()}: ${value}`;
		});

		return headers.join(CRLF);
	};

	const stringToObject = function (headersString, dest) {
		const headers = headersString.split(CRLF);
		if (dest == null) {
			dest = {};
		}

		for (let header of headers) {
			if (/([^:]+):\s*(.+)/.test(header)) {
				const name = RegExp.$1 != null ? RegExp.$1.toLowerCase() : undefined;
				const value = RegExp.$2;
				if (dest[name] == null) {
					dest[name] = value;
				}
			}
		}

		return dest;
	};

	const convert = function (headers, dest) {
		switch (typeof headers) {
			case "object": {
				return objectToString(headers);
			}
			case "string": {
				return stringToObject(headers, dest);
			}
		}

		return [];
	};

	var headers = { convert };

	//global set of hook functions,
	//uses event emitter to store hooks
	const hooks = EventEmitter(true);

	const nullify = (res) => (res === undefined ? null : res);

	//browser's XMLHttpRequest
	const Native$1 = windowRef.XMLHttpRequest;

	//xhook's XMLHttpRequest
	const Xhook$1 = function () {
		const ABORTED = -1;
		const xhr = new Native$1();

		//==========================
		// Extra state
		const request = {};
		let status = null;
		let hasError = undefined;
		let transiting = undefined;
		let response = undefined;
		var currentState = 0;

		//==========================
		// Private API

		//read results from real xhr into response
		const readHead = function () {
			// Accessing attributes on an aborted xhr object will
			// throw an 'c00c023f error' in IE9 and lower, don't touch it.
			response.status = status || xhr.status;
			if (status !== ABORTED) {
				response.statusText = xhr.statusText;
			}
			if (status !== ABORTED) {
				const object = headers.convert(xhr.getAllResponseHeaders());
				for (let key in object) {
					const val = object[key];
					if (!response.headers[key]) {
						const name = key.toLowerCase();
						response.headers[name] = val;
					}
				}
				return;
			}
		};

		const readBody = function () {
			//https://xhr.spec.whatwg.org/
			if (!xhr.responseType || xhr.responseType === "text") {
				response.text = xhr.responseText;
				response.data = xhr.responseText;
				try {
					response.xml = xhr.responseXML;
				} catch (error) {}
				// unable to set responseXML due to response type, we attempt to assign responseXML
				// when the type is text even though it's against the spec due to several libraries
				// and browser vendors who allow this behavior. causing these requests to fail when
				// xhook is installed on a page.
			} else if (xhr.responseType === "document") {
				response.xml = xhr.responseXML;
				response.data = xhr.responseXML;
			} else {
				response.data = xhr.response;
			}
			//new in some browsers
			if ("responseURL" in xhr) {
				//The new code belongs to vite-plugin-fake-server
				response.responseURL = xhr.responseURL;
			}
		};

		//write response into facade xhr
		const writeHead = function () {
			facade.status = response.status;
			facade.statusText = response.statusText;
		};

		const writeBody = function () {
			if ("text" in response) {
				facade.responseText = response.text;
			}
			if ("xml" in response) {
				facade.responseXML = response.xml;
			}
			if ("data" in response) {
				facade.response = response.data;
			} else {
				//https://github.com/jpillora/xhook/issues/173
				//The new code belongs to vite-plugin-fake-server
				const defaultResponseBody = {
					"": "",
					text: "",
					json: null,
					blob: new Blob([], { type: new Headers(response.headers ?? {}).get("content-type") }),
					arraybuffer: new ArrayBuffer(),
				};
				facade.response = defaultResponseBody[facade.responseType];
			}

			//The new code belongs to vite-plugin-fake-server
			if ("responseURL" in response || request.url) {
				facade.responseURL =
					response.responseURL ?? (isLink(request.url) ? request.url : new URL(location.href).origin + request.url);
			}
		};

		const emitFinal = function () {
			if (!hasError) {
				facade.dispatchEvent("load", {});
			}
			facade.dispatchEvent("loadend", {});
			if (hasError) {
				facade.readyState = 0;
			}
		};

		//ensure ready state 0 through 4 is handled
		const emitReadyState = function (n) {
			while (n > currentState && currentState < 4) {
				facade.readyState = ++currentState;
				// make fake events for libraries that actually check the type on
				// the event object
				if (currentState === 1) {
					facade.dispatchEvent("loadstart", {});
				}
				if (currentState === 2) {
					writeHead();
				}
				if (currentState === 4) {
					writeHead();
					writeBody();
				}
				facade.dispatchEvent("readystatechange", {});
				//delay final events incase of error
				if (currentState === 4) {
					if (request.async === false) {
						emitFinal();
					} else {
						setTimeout(emitFinal, 0);
					}
				}
			}
		};

		//control facade ready state
		const setReadyState = function (n) {
			//emit events until readyState reaches 4
			if (n !== 4) {
				emitReadyState(n);
				return;
			}
			//before emitting 4, run all 'after' hooks in sequence
			const afterHooks = hooks.listeners("after");
			var process = function () {
				if (afterHooks.length > 0) {
					//execute each 'before' hook one at a time
					const hook = afterHooks.shift();
					if (hook.length === 2) {
						hook(request, response);
						process();
					} else if (hook.length === 3 && request.async) {
						hook(request, response, process);
					} else {
						process();
					}
				} else {
					//response ready for reading
					emitReadyState(4);
				}
				return;
			};
			process();
		};

		//==========================
		// Facade XHR
		var facade = EventEmitter();
		request.xhr = facade;

		// Handle the underlying ready state
		xhr.onreadystatechange = function (event) {
			//pull status and headers
			try {
				if (xhr.readyState === 2) {
					readHead();
				}
			} catch (error) {}
			//pull response data
			if (xhr.readyState === 4) {
				transiting = false;
				readHead();
				readBody();
			}

			setReadyState(xhr.readyState);
		};

		//mark this xhr as errored
		const hasErrorHandler = function () {
			hasError = true;
		};
		facade.addEventListener("error", hasErrorHandler);
		facade.addEventListener("timeout", hasErrorHandler);
		facade.addEventListener("abort", hasErrorHandler);
		// progress means we're current downloading...
		facade.addEventListener("progress", function (event) {
			if (currentState < 3) {
				setReadyState(3);
			} else if (xhr.readyState <= 3) {
				//until ready (4), each progress event is followed by readystatechange...
				facade.dispatchEvent("readystatechange", {}); //TODO fake an XHR event
			}
		});

		// initialise 'withCredentials' on facade xhr in browsers with it
		// or if explicitly told to do so
		if ("withCredentials" in xhr) {
			facade.withCredentials = false;
		}
		facade.status = 0;

		// initialise all possible event handlers
		for (let event of Array.from(COMMON_EVENTS.concat(UPLOAD_EVENTS))) {
			facade[`on${event}`] = null;
		}

		facade.open = function (method, url, async, user, pass) {
			// Initailize empty XHR facade
			currentState = 0;
			hasError = false;
			transiting = false;
			//reset request
			request.headers = {};
			request.headerNames = {};
			request.status = 0;
			request.method = method;
			request.url = url;
			request.async = async !== false;
			request.user = user;
			request.pass = pass;
			//reset response
			response = {};
			response.headers = {};
			// openned facade xhr (not real xhr)
			setReadyState(1);
		};

		facade.send = function (body) {
			//read xhr settings before hooking
			let k, modk;
			for (k of ["type", "timeout", "withCredentials"]) {
				modk = k === "type" ? "responseType" : k;
				//The new code belongs to vite-plugin-fake-server
				if (modk === "responseType" && !facade._responseTypeChanged) continue;
				if (modk in facade) {
					request[k] = facade[modk];
				}
			}

			request.body = body;
			const send = function () {
				//proxy all events from real xhr to facade
				proxyEvents(COMMON_EVENTS, xhr, facade);
				//proxy all upload events from the real to the upload facade
				if (facade.upload) {
					proxyEvents(COMMON_EVENTS.concat(UPLOAD_EVENTS), xhr.upload, facade.upload);
				}

				//prepare request all at once
				transiting = true;
				//perform open
				xhr.open(request.method, request.url, request.async, request.user, request.pass);

				//write xhr settings
				for (k of ["type", "timeout", "withCredentials"]) {
					modk = k === "type" ? "responseType" : k;
					if (k in request) {
						xhr[modk] = request[k];
					}
				}

				//insert headers
				for (let header in request.headers) {
					const value = request.headers[header];
					if (header) {
						xhr.setRequestHeader(header, value);
					}
				}
				//real send!
				xhr.send(request.body);
			};

			const beforeHooks = hooks.listeners("before");
			//process beforeHooks sequentially
			var process = function () {
				if (!beforeHooks.length) {
					return send();
				}
				//go to next hook OR optionally provide response
				const done = function (userResponse) {
					//break chain - provide dummy response (readyState 4)
					if (
						typeof userResponse === "object" &&
						(typeof userResponse.status === "number" || typeof response.status === "number")
					) {
						mergeObjects(userResponse, response);
						if (!("data" in userResponse)) {
							userResponse.data = userResponse.response || userResponse.text;
						}
						setReadyState(4);
						return;
					}
					//continue processing until no beforeHooks left
					process();
				};
				//specifically provide headers (readyState 2)
				done.head = function (userResponse) {
					mergeObjects(userResponse, response);
					setReadyState(2);
				};
				//specifically provide partial text (responseText  readyState 3)
				done.progress = function (userResponse) {
					mergeObjects(userResponse, response);
					setReadyState(3);
				};

				const hook = beforeHooks.shift();
				/**
				 * The new code belongs to vite-plugin-fake-server
				 *
				 * Original code:
				```
				//async or sync?
				if (hook.length === 1) {
					done(hook(request));
				} else if (hook.length === 2 && request.async) {
					//async handlers must use an async xhr
					hook(request, done);
				} else {
					//skip async hook on sync requests
					done();
				}
				```
				* The new code belongs to vite-plugin-fake-server: Start
				*/
				//async
				if(request.async) {
					if (hook.length === 1) {
						done();
					} else if (hook.length === 2) {
						hook(request, done);
					}
				//sync
				} else {
					if (hook.length === 1) {
						done(hook(request));
					} else if (hook.length === 2) {
						done();
					}
				}
				return;
			};
			// The new code belongs to vite-plugin-fake-server: End
			//kick off
			process();
		};

		facade.abort = function () {
			status = ABORTED;
			if (transiting) {
				xhr.abort(); //this will emit an 'abort' for us
			} else {
				facade.dispatchEvent("abort", {});
			}
		};

		facade.setRequestHeader = function (header, value) {
			//the first header set is used for all future case-alternatives of 'name'
			const lName = header != null ? header.toLowerCase() : undefined;
			const name = (request.headerNames[lName] = request.headerNames[lName] || header);
			//append header to any previous values
			if (request.headers[name]) {
				value = request.headers[name] + ", " + value;
			}
			request.headers[name] = value;
		};
		facade.getResponseHeader = (header) => nullify(response.headers[header ? header.toLowerCase() : undefined]);

		facade.getAllResponseHeaders = () => nullify(headers.convert(response.headers));

		//proxy call only when supported
		if (xhr.overrideMimeType) {
			facade.overrideMimeType = function () {
				xhr.overrideMimeType.apply(xhr, arguments);
			};
		}

		//create emitter when supported
		if (xhr.upload) {
			let up = EventEmitter();
			facade.upload = up;
			request.upload = up;
		}

		facade.UNSENT = 0;
		facade.OPENED = 1;
		facade.HEADERS_RECEIVED = 2;
		facade.LOADING = 3;
		facade.DONE = 4;

		// fill in default values for an empty XHR object according to the spec
		facade.response = "";
		facade.responseText = "";
		facade.responseXML = null;
		facade.readyState = 0;
		facade.statusText = "";
		facade._responseTypeChanged = false;
		// The new code belongs to vite-plugin-fake-server
		/*====================== START ======================*/
		let innerResponseType = "";
		Object.defineProperty(facade, "responseType", {
			get: () => innerResponseType,
			set: (newValue) => {
				facade._responseTypeChanged = true;
				innerResponseType = newValue;
			},
			enumerable: true,
			configurable: true
		});
		/*====================== END ======================*/

		return facade;
	};

	Xhook$1.UNSENT = 0;
	Xhook$1.OPENED = 1;
	Xhook$1.HEADERS_RECEIVED = 2;
	Xhook$1.LOADING = 3;
	Xhook$1.DONE = 4;

	//patch interface
	var XMLHttpRequest = {
		patch() {
			if (Native$1) {
				windowRef.XMLHttpRequest = Xhook$1;
			}
		},
		unpatch() {
			if (Native$1) {
				windowRef.XMLHttpRequest = Native$1;
			}
		},
		Native: Native$1,
		Xhook: Xhook$1,
	};

	/******************************************************************************
  Copyright (c) Microsoft Corporation.

  Permission to use, copy, modify, and/or distribute this software for any
  purpose with or without fee is hereby granted.

  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
  REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
  AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
  INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
  LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
  OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
  PERFORMANCE OF THIS SOFTWARE.
  ***************************************************************************** */

	function __rest(s, e) {
		var t = {};
		for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
		if (s != null && typeof Object.getOwnPropertySymbols === "function")
			for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
				if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
			}
		return t;
	}

	function __awaiter(thisArg, _arguments, P, generator) {
		function adopt(value) {
			return value instanceof P
				? value
				: new P(function (resolve) {
						resolve(value);
					});
		}
		return new (P || (P = Promise))(function (resolve, reject) {
			function fulfilled(value) {
				try {
					step(generator.next(value));
				} catch (e) {
					reject(e);
				}
			}
			function rejected(value) {
				try {
					step(generator["throw"](value));
				} catch (e) {
					reject(e);
				}
			}
			function step(result) {
				result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
			}
			step((generator = generator.apply(thisArg, [])).next());
		});
	}

	//browser's fetch
	const Native = windowRef.fetch;
	function copyToObjFromRequest(req) {
		const copyedKeys = [
			"method",
			"headers",
			"body",
			"mode",
			"credentials",
			"cache",
			"redirect",
			"referrer",
			"referrerPolicy",
			"integrity",
			"keepalive",
			"signal",
			"url",
		];
		let copyedObj = {};
		copyedKeys.forEach((key) => (copyedObj[key] = req[key]));
		return copyedObj;
	}
	function covertHeaderToPlainObj(headers) {
		if (headers instanceof Headers) {
			return covertTDAarryToObj([...headers.entries()]);
		}
		if (Array.isArray(headers)) {
			return covertTDAarryToObj(headers);
		}
		return headers;
	}
	function covertTDAarryToObj(input) {
		return input.reduce((prev, [key, value]) => {
			prev[key] = value;
			return prev;
		}, {});
	}
	/**
	 * if fetch(hacked by Xhook) accept a Request as a first parameter, it will be destrcuted to a plain object.
	 * Finally the whole network request was convert to fectch(Request.url, other options)
	 */
	const Xhook = function (input, init = { headers: {} }) {
		let options = Object.assign(Object.assign({}, init), { isFetch: true });
		if (input instanceof Request) {
			const requestObj = copyToObjFromRequest(input);
			const prevHeaders = Object.assign(
				Object.assign({}, covertHeaderToPlainObj(requestObj.headers)),
				covertHeaderToPlainObj(options.headers),
			);
			options = Object.assign(Object.assign(Object.assign({}, requestObj), init), {
				headers: prevHeaders,
				acceptedRequest: true,
				//The new code belongs to vite-plugin-fake-server
				isFetch: true,
			});
		} else {
			options.url = input;
		}
		const beforeHooks = hooks.listeners("before");
		const afterHooks = hooks.listeners("after");
		return new Promise(function (resolve, reject) {
			let fullfiled = resolve;
			const processAfter = function (response) {
				if (!afterHooks.length) {
					return fullfiled(response);
				}
				const hook = afterHooks.shift();
				if (hook.length === 2) {
					hook(options, response);
					return processAfter(response);
				} else if (hook.length === 3) {
					return hook(options, response, processAfter);
				} else {
					return processAfter(response);
				}
			};
			const done = function (userResponse) {
				if (userResponse !== undefined) {
					const response = new Response(userResponse.body || userResponse.text, userResponse);
					//The new code belongs to vite-plugin-fake-server
					Object.defineProperty(response, "url", {
						value: isLink(options.url) ? options.url : new URL(location.href).origin + options.url,
					});
					resolve(response);
					processAfter(response);
					return;
				}
				//continue processing until no hooks left
				processBefore();
			};
			const processBefore = function () {
				if (!beforeHooks.length) {
					send();
					return;
				}
				const hook = beforeHooks.shift();
				if (hook.length === 1) {
					// return done(hook(options));
					//The new code belongs to vite-plugin-fake-server
					return done();
				} else if (hook.length === 2) {
					return hook(options, done);
				}
			};
			const send = () =>
				__awaiter(this, void 0, void 0, function* () {
					const { url, isFetch, acceptedRequest } = options,
						restInit = __rest(options, ["url", "isFetch", "acceptedRequest"]);
					if (input instanceof Request && restInit.body instanceof ReadableStream) {
						restInit.body = yield new Response(restInit.body).text();
					}
					return Native(url, restInit)
						.then((response) => processAfter(response))
						.catch(function (err) {
							fullfiled = reject;
							processAfter(err);
							return reject(err);
						});
				});
			processBefore();
		});
	};
	//patch interface
	var fetch = {
		patch() {
			if (Native) {
				windowRef.fetch = Xhook;
			}
		},
		unpatch() {
			if (Native) {
				windowRef.fetch = Native;
			}
		},
		Native,
		Xhook,
	};

	//the global hooks event emitter is also the global xhook object
	//(not the best decision in hindsight)
	const xhook = hooks;
	xhook.EventEmitter = EventEmitter;
	//modify hooks
	xhook.before = function (handler, i) {
		if (handler.length < 1 || handler.length > 2) {
			throw "invalid hook";
		}
		return xhook.on("before", handler, i);
	};
	xhook.after = function (handler, i) {
		if (handler.length < 2 || handler.length > 3) {
			throw "invalid hook";
		}
		return xhook.on("after", handler, i);
	};

	//globally enable/disable
	xhook.enable = function () {
		XMLHttpRequest.patch();
		fetch.patch();
	};
	xhook.disable = function () {
		XMLHttpRequest.unpatch();
		fetch.unpatch();
	};
	//expose native objects
	xhook.XMLHttpRequest = XMLHttpRequest.Native;
	xhook.fetch = fetch.Native;

	//expose helpers
	xhook.headers = headers.convert;

	//enable by default
	xhook.enable();

	return xhook;
}

async function vitePluginFakeServer(options = {}) {
  let config;
  let isDevServer = false;
  let opts;
  return {
    name: "vite-plugin-fake-server",
    config: (unresolvedConfig) => {
      const currentWorkingDirectory = process.cwd();
      const root = unresolvedConfig.root ?? currentWorkingDirectory;
      const absoluteRoot = isAbsolute(root) ? root : join(currentWorkingDirectory, root);
      opts = resolvePluginOptions({ ...options, http2: options.http2 ?? !!unresolvedConfig.server }, absoluteRoot);
      return {
        server: {
          watch: {
            ignored: resolveIgnored(absoluteRoot, opts.include, unresolvedConfig?.server?.watch)
          }
        }
      };
    },
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      if (resolvedConfig.command === "serve") {
        isDevServer = true;
      }
    },
    async configureServer({ middlewares, httpServer }) {
      if (isDevServer && opts.enableDev) {
        const loggerOutput = createLogger(config.logLevel, {
          allowClearScreen: config.clearScreen,
          customLogger: config.customLogger
        });
        const middleware = await createFakeMiddleware({ ...opts, loggerOutput, root: config.root }, httpServer);
        middlewares.use(middleware);
      }
    },
    transformIndexHtml: {
      order: "pre",
      handler: async (htmlString) => {
        if (isDevServer || !opts.enableProd) {
          return htmlString;
        }
        const scriptTagOptions = {
          tag: "script",
          attrs: { type: "module" },
          injectTo: "head"
        };
        const scriptTagList = [];
        if (opts.logger) {
          scriptTagList.push({
            ...scriptTagOptions,
            children: [
              'console.warn("[',
              pkg.name,
              "]:",
              "The plugin is applied in the production environment, check in https://github.com/condorheroblog/vite-plugin-fake-server#enableprod",
              '");'
            ].join("")
          });
        }
        scriptTagList.push({
          ...scriptTagOptions,
          children: [
            "window.__VITE__PLUGIN__FAKE__SERVER__",
            "=",
            JSON.stringify({ meta: pkg, vitePluginFakeServerOptions: opts }, null, 2),
            ";"
          ].join("")
        });
        const fakeFilePath = getFakeFilePath(
          {
            include: opts.include,
            exclude: opts.exclude,
            extensions: opts.extensions,
            infixName: opts.infixName
          },
          config.root
        );
        const relativeFakeFilePath = fakeFilePath.map((filePath) => `/${filePath}`);
        const fakeTemplate = `
					const modules = import.meta.glob(${JSON.stringify(relativeFakeFilePath, null, 2)}, { eager: true });
					const fakeModuleList = Object.keys(modules).reduce((list, key) => {
						const module = modules[key] ?? {};
						if (module.default) {
							for (const moduleKey of Object.keys(module)) {
								const mod = modules[key][moduleKey] ?? [];
								const modList = Array.isArray(mod) ? [...mod] : [mod];
								return [...list, ...modList];
							}
						} else {
							return list;
						}
					}, []);
					window.__VITE__PLUGIN__FAKE__SERVER__.fakeModuleList = fakeModuleList;
				`;
        scriptTagList.push({
          ...scriptTagOptions,
          children: fakeTemplate
        });
        scriptTagList.push({
          ...scriptTagOptions,
          children: `${xhook.toString()};window.__VITE__PLUGIN__FAKE__SERVER__.xhook=xhook();`
        });
        const pathToRegexpContent = await buildPackage("path-to-regexp");
        scriptTagList.push({
          ...scriptTagOptions,
          children: `${pathToRegexpContent}`
        });
        scriptTagList.push({
          ...scriptTagOptions,
          children: `const fakeModuleList = window.__VITE__PLUGIN__FAKE__SERVER__.fakeModuleList;
					const pathToRegexp = window.__VITE__PLUGIN__FAKE__SERVER__.pathToRegexp;
					const match = pathToRegexp.match ?? pathToRegexp.default.match;
					// sync
					window.__VITE__PLUGIN__FAKE__SERVER__.xhook.before(${createHookTemplate(false, opts)});
					// async
					window.__VITE__PLUGIN__FAKE__SERVER__.xhook.before(${createHookTemplate(true, opts)});`
        });
        return scriptTagList;
      }
    },
    async closeBundle() {
      if (!isDevServer && opts.build) {
        await generateFakeServer(opts, config);
      }
    }
  };
}
function resolveIgnored(rootDir, include, watchOptions) {
  const { ignored = [] } = watchOptions ?? {};
  return [
    ...include.map((includePath) => normalizePath(join(rootDir, includePath, "**"))),
    ...Array.isArray(ignored) ? ignored : [ignored]
  ];
}

export { FAKE_FILE_EXTENSIONS, FakeFileLoader, INFIX_NAME, LogLevels, OUTPUT_DIR, PORT, buildPackage, copyFakeFiles, createFakeMiddleware, createLogger, createSimulateResponse, defineFakeRoute, generateFakeServer, getFakeFilePath, getRequestData, getWatchPaths, isFunction, parallelLoader, resolveIgnored, resolveOptions, resolvePluginOptions, simulateServerResponse, simulateServerResponseSync, sleep, sleepSync, tryToJSON, version, vitePluginFakeServer };
